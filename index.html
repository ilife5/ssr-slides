<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>React-ssr 核心技术分析</h3>
					<p>用户增长技术 姚冀锋</p>
				</section>
				<section>
					<h4>自我介绍</h4>
					<ul>
						<li>从jquery到react</li>
						<li>从前到后</li>
						<li>从全栈到全站</li>
					</ul>
				</section>
				<section>
					<h4>拆解和定义</h4>

					<section>
						<p>传统意义上的SSR是什么？</p>
					</section>

					<section>
						<p>页面由服务端直接返回给浏览器，路由为服务端路由，URL的变更会刷新页面。</p>
					</section>

					<section>
						<p>下面这些方式哪些是“传统的”SSR？</p>
						<ul>
							<li>JSP，ASP，PHP数据直出</li>
							<li>Express(Nodejs)数据直出 </li>
							<li>SPA（React+router+ajax）</li>
						</ul>
					</section>

					<section>
						<p>现在业内所说的SSR</p>
						<p>用服务端渲染首屏，首屏之后的路由由客户端控制。</p>
					</section>
				</section>

				<section>
					<h4>SSR的价值在哪里？</h4>

					<section>
						<p>SSR和CSR的比较</p>
					</section>

					<section>
						<ul>
							<li>服务端渲染对于前端应用的首屏加载速度有着质的提升</li>
							<li>对SEO友好</li>
							<li>兼容性好</li>
							<li>引入nodejs中间层，技术赋能</li>
							<li>服务端可以更早对当前URL做业务逻辑上的判断</li>
							<li>对弱交互的网站合适</li>
						</ul>
					</section>

					<section>
						<p>ssr会有哪些问题</p>
						<ul></ul>
					</section>

					<section>
						<p>如何判断，我们是否应该使用ssr</p>
						<ul></ul>
					</section>
				</section>

				<section>
					<section>
						<p>React是什么？</p>
					</section>

					<section>
						<ul>
							<li>用于构建用户界面的 JavaScript 库</li>
							<li>声明式；组件化；一次学习，随处编写</li>
							<li>无论你现在正在使用什么技术栈，你都可以随时引入 React 来开发新特性，而不需要重写现有代码。
								React <span class="fragment highlight-red">还可以</span>使用 <span class="fragment highlight-red">Node</span> 进行服务器渲染，或使用 <span class="fragment highlight-red">React Native</span> 开发原生移动应用。</li>
						</ul>
					</section>
				</section>
				<section>
					<section>Isomorphic，同构技术</section>

					<section>
						<ul>
							<li>编写的Javascript代码可同时运行在浏览器及Node.js两套环境中</li>
							<li>结合好同构技术，可以同时利用SSR和CSR的优点</li>
							<li>也可以规避SSR和CSR两者的缺点</li>
						</ul>
					</section>

					<section>
						<p>一个完整的ssr流程</p>
						<ul style="font-size: 24px;">
							<li>浏览器与服务器复用同一套代码与路由</li>
							<li>编译出来的代码要便于部署，不要太多依赖</li>
							<li>浏览器载入的首屏由服务器渲染完成，以提高加载速度和利于 SEO</li>
							<li>浏览器不再重复做服务器已完成的渲染工作（包括不再重复的请求数据）</li>
							<li>首屏后不再整体刷新，而是通过 ajax 局部更新，带来单页的用户体验</li>
							<li>在交互过程中，随时刷新页面，可以通过 URL 重现当前内容（包括打开弹窗等动作）</li>
							<li>所有的路由跳转 link 回归到原始的\< a href="...">，方便让搜索引擎爬取</li>
							<li>JS 拦截所有\< a href="...">的浏览器跳转行为，使用浏览器中的路由</li>
						</ul>
					</section>
				</section>

				<section>
					<section>核心技术</section>
					<section>
						<pre><code>
// React v16.2.0
import ReactDOMServer from 'react-dom/server';

//把React element 渲染成html字符串
ReactDOMServer.renderToString(element)
						</code></pre>

						<pre><code>
// React v16.2.0
import ReactDOM from 'react-dom'

//与 render() 相同，但它用于在 ReactDOMServer 渲染的容器中
//对 HTML 的内容进行 hydrate 操作。React 会尝试在已有标记上
//绑定事件监听器。
ReactDOM.hydrate(element, container[, callback])
						</code></pre>
					</section>

					<section>
						Example
					</section>

					<section>
						<p>使用ssr要考虑的事情</p>

						<ul>
							<li>在前端框架没有执行完之前，可看不可交互。</li>
							<li>ReactDOMServer.renderToString是同步方法、在调用过程中，会绑定CPU（属于 CPU 独享型）、会阻塞整个事件循环流程。在renderToString没有执行完之前，服务器是不可能处理其它请求的</li>
							<li>增加维护成本，node设施和发布成本</li>
						</ul>

					</section>

					<section>
						<p>什么场景应该考虑用ssr</p>

						<ul>
							<li>首屏的加载速度非常重要</li>
							<li>内容需要登陆之后才可见</li>
							<li>SEO是否非常重要</li>
							<li>写视图大于读视图</li>
						</ul>

					</section>
				</section>

				<section>
					<p>商业化使用的距离</p>
					<ul>
						<li>性能瓶颈在哪里，该如何优化？</li>
						<li>引入node之后，对ES6/7的支持</li>
						<li>对image和css的处理</li>
						<li>对构建的支持</li>
						<li>服务降级</li>
						<li>监控与报警（全链路监控）</li>
					</ul>
				</section>

				<section>
					<section>
						目前的业内技术栈
					</section>

					<section>
						<table>
							<tr>
								<th>名称</th>
								<th>特点</th>
							</tr>
							<tr>
								<td>Razzle</td>
								<td>HMR,same CSS setup</td>
							</tr>
							<tr>
								<td>React Server</td>
								<td>by Redlfin</td>
							</tr>
							<tr>
								<td>Next</td>
								<td>minimalistic framework for ssr applications</td>
							</tr>
							<tr>
								<td>beidou</td>
								<td>By alibaba 高并发方案，支持自动路由</td>
							</tr>
							<tr>
								<td>samsung-ssr</td>
								<td></td>
							</tr>
							<tr>
								<td>ykfe（egg-react-ssr）</td>
								<td></td>
							</tr>
						</table>
					</section>
				</section>

				<section>
					<section>
						举个栗子：现实中的使用场景
					</section>

					<section>
						电商运营中心

						<section>
							<p>特点</p>

							<ul>
								<p>页面访问量大，地域差距大，静态资源对服务器压力高</p>
								<p>对首屏的展示速度要求高</p>
							</ul>
						</section>

						<p>模板维护系统，维护模板和数据schema</p>
						<p>内部运营平台，使用schema动态生成表单</p>
						<p>使用SSR技术集成模板和数据做在线预览，发布至CDN</p>
					</section>
				</section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				],
				// Display the page number of the current slide
				slideNumber: true,

				// Add the current slide number to the URL hash so that reloading the
				// page/copying the URL will return you to the same slide
				hash: true,

				// Push each slide change to the browser history. Implies `hash: true`
				history: true
			});
		</script>
	</body>
</html>
